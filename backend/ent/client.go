// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/sut63/team05/ent/migrate"

	"github.com/sut63/team05/ent/bank"
	"github.com/sut63/team05/ent/category"
	"github.com/sut63/team05/ent/gender"
	"github.com/sut63/team05/ent/groupofage"
	"github.com/sut63/team05/ent/hospital"
	"github.com/sut63/team05/ent/inquiry"
	"github.com/sut63/team05/ent/insurance"
	"github.com/sut63/team05/ent/member"
	"github.com/sut63/team05/ent/moneytransfer"
	"github.com/sut63/team05/ent/officer"
	"github.com/sut63/team05/ent/payment"
	"github.com/sut63/team05/ent/product"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Bank is the client for interacting with the Bank builders.
	Bank *BankClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// Gender is the client for interacting with the Gender builders.
	Gender *GenderClient
	// GroupOfAge is the client for interacting with the GroupOfAge builders.
	GroupOfAge *GroupOfAgeClient
	// Hospital is the client for interacting with the Hospital builders.
	Hospital *HospitalClient
	// Inquiry is the client for interacting with the Inquiry builders.
	Inquiry *InquiryClient
	// Insurance is the client for interacting with the Insurance builders.
	Insurance *InsuranceClient
	// Member is the client for interacting with the Member builders.
	Member *MemberClient
	// MoneyTransfer is the client for interacting with the MoneyTransfer builders.
	MoneyTransfer *MoneyTransferClient
	// Officer is the client for interacting with the Officer builders.
	Officer *OfficerClient
	// Payment is the client for interacting with the Payment builders.
	Payment *PaymentClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Bank = NewBankClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.Gender = NewGenderClient(c.config)
	c.GroupOfAge = NewGroupOfAgeClient(c.config)
	c.Hospital = NewHospitalClient(c.config)
	c.Inquiry = NewInquiryClient(c.config)
	c.Insurance = NewInsuranceClient(c.config)
	c.Member = NewMemberClient(c.config)
	c.MoneyTransfer = NewMoneyTransferClient(c.config)
	c.Officer = NewOfficerClient(c.config)
	c.Payment = NewPaymentClient(c.config)
	c.Product = NewProductClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Bank:          NewBankClient(cfg),
		Category:      NewCategoryClient(cfg),
		Gender:        NewGenderClient(cfg),
		GroupOfAge:    NewGroupOfAgeClient(cfg),
		Hospital:      NewHospitalClient(cfg),
		Inquiry:       NewInquiryClient(cfg),
		Insurance:     NewInsuranceClient(cfg),
		Member:        NewMemberClient(cfg),
		MoneyTransfer: NewMoneyTransferClient(cfg),
		Officer:       NewOfficerClient(cfg),
		Payment:       NewPaymentClient(cfg),
		Product:       NewProductClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:        cfg,
		Bank:          NewBankClient(cfg),
		Category:      NewCategoryClient(cfg),
		Gender:        NewGenderClient(cfg),
		GroupOfAge:    NewGroupOfAgeClient(cfg),
		Hospital:      NewHospitalClient(cfg),
		Inquiry:       NewInquiryClient(cfg),
		Insurance:     NewInsuranceClient(cfg),
		Member:        NewMemberClient(cfg),
		MoneyTransfer: NewMoneyTransferClient(cfg),
		Officer:       NewOfficerClient(cfg),
		Payment:       NewPaymentClient(cfg),
		Product:       NewProductClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Bank.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Bank.Use(hooks...)
	c.Category.Use(hooks...)
	c.Gender.Use(hooks...)
	c.GroupOfAge.Use(hooks...)
	c.Hospital.Use(hooks...)
	c.Inquiry.Use(hooks...)
	c.Insurance.Use(hooks...)
	c.Member.Use(hooks...)
	c.MoneyTransfer.Use(hooks...)
	c.Officer.Use(hooks...)
	c.Payment.Use(hooks...)
	c.Product.Use(hooks...)
}

// BankClient is a client for the Bank schema.
type BankClient struct {
	config
}

// NewBankClient returns a client for the Bank from the given config.
func NewBankClient(c config) *BankClient {
	return &BankClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bank.Hooks(f(g(h())))`.
func (c *BankClient) Use(hooks ...Hook) {
	c.hooks.Bank = append(c.hooks.Bank, hooks...)
}

// Create returns a create builder for Bank.
func (c *BankClient) Create() *BankCreate {
	mutation := newBankMutation(c.config, OpCreate)
	return &BankCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Bank.
func (c *BankClient) Update() *BankUpdate {
	mutation := newBankMutation(c.config, OpUpdate)
	return &BankUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BankClient) UpdateOne(b *Bank) *BankUpdateOne {
	mutation := newBankMutation(c.config, OpUpdateOne, withBank(b))
	return &BankUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BankClient) UpdateOneID(id int) *BankUpdateOne {
	mutation := newBankMutation(c.config, OpUpdateOne, withBankID(id))
	return &BankUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Bank.
func (c *BankClient) Delete() *BankDelete {
	mutation := newBankMutation(c.config, OpDelete)
	return &BankDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BankClient) DeleteOne(b *Bank) *BankDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BankClient) DeleteOneID(id int) *BankDeleteOne {
	builder := c.Delete().Where(bank.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BankDeleteOne{builder}
}

// Create returns a query builder for Bank.
func (c *BankClient) Query() *BankQuery {
	return &BankQuery{config: c.config}
}

// Get returns a Bank entity by its id.
func (c *BankClient) Get(ctx context.Context, id int) (*Bank, error) {
	return c.Query().Where(bank.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BankClient) GetX(ctx context.Context, id int) *Bank {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// QueryBankPayment queries the bank_payment edge of a Bank.
func (c *BankClient) QueryBankPayment(b *Bank) *PaymentQuery {
	query := &PaymentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bank.Table, bank.FieldID, id),
			sqlgraph.To(payment.Table, payment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bank.BankPaymentTable, bank.BankPaymentColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BankClient) Hooks() []Hook {
	return c.hooks.Bank
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Create returns a create builder for Category.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Create returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{config: c.config}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	ca, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ca
}

// QueryCategoryInquiry queries the category_inquiry edge of a Category.
func (c *CategoryClient) QueryCategoryInquiry(ca *Category) *InquiryQuery {
	query := &InquiryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(inquiry.Table, inquiry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.CategoryInquiryTable, category.CategoryInquiryColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// GenderClient is a client for the Gender schema.
type GenderClient struct {
	config
}

// NewGenderClient returns a client for the Gender from the given config.
func NewGenderClient(c config) *GenderClient {
	return &GenderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gender.Hooks(f(g(h())))`.
func (c *GenderClient) Use(hooks ...Hook) {
	c.hooks.Gender = append(c.hooks.Gender, hooks...)
}

// Create returns a create builder for Gender.
func (c *GenderClient) Create() *GenderCreate {
	mutation := newGenderMutation(c.config, OpCreate)
	return &GenderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Gender.
func (c *GenderClient) Update() *GenderUpdate {
	mutation := newGenderMutation(c.config, OpUpdate)
	return &GenderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GenderClient) UpdateOne(ge *Gender) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGender(ge))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GenderClient) UpdateOneID(id int) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGenderID(id))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Gender.
func (c *GenderClient) Delete() *GenderDelete {
	mutation := newGenderMutation(c.config, OpDelete)
	return &GenderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GenderClient) DeleteOne(ge *Gender) *GenderDeleteOne {
	return c.DeleteOneID(ge.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GenderClient) DeleteOneID(id int) *GenderDeleteOne {
	builder := c.Delete().Where(gender.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GenderDeleteOne{builder}
}

// Create returns a query builder for Gender.
func (c *GenderClient) Query() *GenderQuery {
	return &GenderQuery{config: c.config}
}

// Get returns a Gender entity by its id.
func (c *GenderClient) Get(ctx context.Context, id int) (*Gender, error) {
	return c.Query().Where(gender.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GenderClient) GetX(ctx context.Context, id int) *Gender {
	ge, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ge
}

// QueryGenders queries the genders edge of a Gender.
func (c *GenderClient) QueryGenders(ge *Gender) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gender.Table, gender.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gender.GendersTable, gender.GendersColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GenderClient) Hooks() []Hook {
	return c.hooks.Gender
}

// GroupOfAgeClient is a client for the GroupOfAge schema.
type GroupOfAgeClient struct {
	config
}

// NewGroupOfAgeClient returns a client for the GroupOfAge from the given config.
func NewGroupOfAgeClient(c config) *GroupOfAgeClient {
	return &GroupOfAgeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupofage.Hooks(f(g(h())))`.
func (c *GroupOfAgeClient) Use(hooks ...Hook) {
	c.hooks.GroupOfAge = append(c.hooks.GroupOfAge, hooks...)
}

// Create returns a create builder for GroupOfAge.
func (c *GroupOfAgeClient) Create() *GroupOfAgeCreate {
	mutation := newGroupOfAgeMutation(c.config, OpCreate)
	return &GroupOfAgeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for GroupOfAge.
func (c *GroupOfAgeClient) Update() *GroupOfAgeUpdate {
	mutation := newGroupOfAgeMutation(c.config, OpUpdate)
	return &GroupOfAgeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupOfAgeClient) UpdateOne(goa *GroupOfAge) *GroupOfAgeUpdateOne {
	mutation := newGroupOfAgeMutation(c.config, OpUpdateOne, withGroupOfAge(goa))
	return &GroupOfAgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupOfAgeClient) UpdateOneID(id int) *GroupOfAgeUpdateOne {
	mutation := newGroupOfAgeMutation(c.config, OpUpdateOne, withGroupOfAgeID(id))
	return &GroupOfAgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupOfAge.
func (c *GroupOfAgeClient) Delete() *GroupOfAgeDelete {
	mutation := newGroupOfAgeMutation(c.config, OpDelete)
	return &GroupOfAgeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GroupOfAgeClient) DeleteOne(goa *GroupOfAge) *GroupOfAgeDeleteOne {
	return c.DeleteOneID(goa.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GroupOfAgeClient) DeleteOneID(id int) *GroupOfAgeDeleteOne {
	builder := c.Delete().Where(groupofage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupOfAgeDeleteOne{builder}
}

// Create returns a query builder for GroupOfAge.
func (c *GroupOfAgeClient) Query() *GroupOfAgeQuery {
	return &GroupOfAgeQuery{config: c.config}
}

// Get returns a GroupOfAge entity by its id.
func (c *GroupOfAgeClient) Get(ctx context.Context, id int) (*GroupOfAge, error) {
	return c.Query().Where(groupofage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupOfAgeClient) GetX(ctx context.Context, id int) *GroupOfAge {
	goa, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return goa
}

// QueryGropages queries the gropages edge of a GroupOfAge.
func (c *GroupOfAgeClient) QueryGropages(goa *GroupOfAge) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := goa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupofage.Table, groupofage.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, groupofage.GropagesTable, groupofage.GropagesColumn),
		)
		fromV = sqlgraph.Neighbors(goa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupOfAgeClient) Hooks() []Hook {
	return c.hooks.GroupOfAge
}

// HospitalClient is a client for the Hospital schema.
type HospitalClient struct {
	config
}

// NewHospitalClient returns a client for the Hospital from the given config.
func NewHospitalClient(c config) *HospitalClient {
	return &HospitalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hospital.Hooks(f(g(h())))`.
func (c *HospitalClient) Use(hooks ...Hook) {
	c.hooks.Hospital = append(c.hooks.Hospital, hooks...)
}

// Create returns a create builder for Hospital.
func (c *HospitalClient) Create() *HospitalCreate {
	mutation := newHospitalMutation(c.config, OpCreate)
	return &HospitalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Hospital.
func (c *HospitalClient) Update() *HospitalUpdate {
	mutation := newHospitalMutation(c.config, OpUpdate)
	return &HospitalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HospitalClient) UpdateOne(h *Hospital) *HospitalUpdateOne {
	mutation := newHospitalMutation(c.config, OpUpdateOne, withHospital(h))
	return &HospitalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HospitalClient) UpdateOneID(id int) *HospitalUpdateOne {
	mutation := newHospitalMutation(c.config, OpUpdateOne, withHospitalID(id))
	return &HospitalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hospital.
func (c *HospitalClient) Delete() *HospitalDelete {
	mutation := newHospitalMutation(c.config, OpDelete)
	return &HospitalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *HospitalClient) DeleteOne(h *Hospital) *HospitalDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *HospitalClient) DeleteOneID(id int) *HospitalDeleteOne {
	builder := c.Delete().Where(hospital.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HospitalDeleteOne{builder}
}

// Create returns a query builder for Hospital.
func (c *HospitalClient) Query() *HospitalQuery {
	return &HospitalQuery{config: c.config}
}

// Get returns a Hospital entity by its id.
func (c *HospitalClient) Get(ctx context.Context, id int) (*Hospital, error) {
	return c.Query().Where(hospital.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HospitalClient) GetX(ctx context.Context, id int) *Hospital {
	h, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return h
}

// QueryHospitalInsurance queries the hospital_insurance edge of a Hospital.
func (c *HospitalClient) QueryHospitalInsurance(h *Hospital) *InsuranceQuery {
	query := &InsuranceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hospital.Table, hospital.FieldID, id),
			sqlgraph.To(insurance.Table, insurance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hospital.HospitalInsuranceTable, hospital.HospitalInsuranceColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HospitalClient) Hooks() []Hook {
	return c.hooks.Hospital
}

// InquiryClient is a client for the Inquiry schema.
type InquiryClient struct {
	config
}

// NewInquiryClient returns a client for the Inquiry from the given config.
func NewInquiryClient(c config) *InquiryClient {
	return &InquiryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inquiry.Hooks(f(g(h())))`.
func (c *InquiryClient) Use(hooks ...Hook) {
	c.hooks.Inquiry = append(c.hooks.Inquiry, hooks...)
}

// Create returns a create builder for Inquiry.
func (c *InquiryClient) Create() *InquiryCreate {
	mutation := newInquiryMutation(c.config, OpCreate)
	return &InquiryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Inquiry.
func (c *InquiryClient) Update() *InquiryUpdate {
	mutation := newInquiryMutation(c.config, OpUpdate)
	return &InquiryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InquiryClient) UpdateOne(i *Inquiry) *InquiryUpdateOne {
	mutation := newInquiryMutation(c.config, OpUpdateOne, withInquiry(i))
	return &InquiryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InquiryClient) UpdateOneID(id int) *InquiryUpdateOne {
	mutation := newInquiryMutation(c.config, OpUpdateOne, withInquiryID(id))
	return &InquiryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Inquiry.
func (c *InquiryClient) Delete() *InquiryDelete {
	mutation := newInquiryMutation(c.config, OpDelete)
	return &InquiryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InquiryClient) DeleteOne(i *Inquiry) *InquiryDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InquiryClient) DeleteOneID(id int) *InquiryDeleteOne {
	builder := c.Delete().Where(inquiry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InquiryDeleteOne{builder}
}

// Create returns a query builder for Inquiry.
func (c *InquiryClient) Query() *InquiryQuery {
	return &InquiryQuery{config: c.config}
}

// Get returns a Inquiry entity by its id.
func (c *InquiryClient) Get(ctx context.Context, id int) (*Inquiry, error) {
	return c.Query().Where(inquiry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InquiryClient) GetX(ctx context.Context, id int) *Inquiry {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// QueryMember queries the Member edge of a Inquiry.
func (c *InquiryClient) QueryMember(i *Inquiry) *MemberQuery {
	query := &MemberQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inquiry.Table, inquiry.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inquiry.MemberTable, inquiry.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the Category edge of a Inquiry.
func (c *InquiryClient) QueryCategory(i *Inquiry) *CategoryQuery {
	query := &CategoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inquiry.Table, inquiry.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inquiry.CategoryTable, inquiry.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOfficer queries the Officer edge of a Inquiry.
func (c *InquiryClient) QueryOfficer(i *Inquiry) *OfficerQuery {
	query := &OfficerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inquiry.Table, inquiry.FieldID, id),
			sqlgraph.To(officer.Table, officer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inquiry.OfficerTable, inquiry.OfficerColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the Product edge of a Inquiry.
func (c *InquiryClient) QueryProduct(i *Inquiry) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inquiry.Table, inquiry.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inquiry.ProductTable, inquiry.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InquiryClient) Hooks() []Hook {
	return c.hooks.Inquiry
}

// InsuranceClient is a client for the Insurance schema.
type InsuranceClient struct {
	config
}

// NewInsuranceClient returns a client for the Insurance from the given config.
func NewInsuranceClient(c config) *InsuranceClient {
	return &InsuranceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `insurance.Hooks(f(g(h())))`.
func (c *InsuranceClient) Use(hooks ...Hook) {
	c.hooks.Insurance = append(c.hooks.Insurance, hooks...)
}

// Create returns a create builder for Insurance.
func (c *InsuranceClient) Create() *InsuranceCreate {
	mutation := newInsuranceMutation(c.config, OpCreate)
	return &InsuranceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Insurance.
func (c *InsuranceClient) Update() *InsuranceUpdate {
	mutation := newInsuranceMutation(c.config, OpUpdate)
	return &InsuranceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InsuranceClient) UpdateOne(i *Insurance) *InsuranceUpdateOne {
	mutation := newInsuranceMutation(c.config, OpUpdateOne, withInsurance(i))
	return &InsuranceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InsuranceClient) UpdateOneID(id int) *InsuranceUpdateOne {
	mutation := newInsuranceMutation(c.config, OpUpdateOne, withInsuranceID(id))
	return &InsuranceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Insurance.
func (c *InsuranceClient) Delete() *InsuranceDelete {
	mutation := newInsuranceMutation(c.config, OpDelete)
	return &InsuranceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InsuranceClient) DeleteOne(i *Insurance) *InsuranceDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InsuranceClient) DeleteOneID(id int) *InsuranceDeleteOne {
	builder := c.Delete().Where(insurance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InsuranceDeleteOne{builder}
}

// Create returns a query builder for Insurance.
func (c *InsuranceClient) Query() *InsuranceQuery {
	return &InsuranceQuery{config: c.config}
}

// Get returns a Insurance entity by its id.
func (c *InsuranceClient) Get(ctx context.Context, id int) (*Insurance, error) {
	return c.Query().Where(insurance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InsuranceClient) GetX(ctx context.Context, id int) *Insurance {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// QueryMember queries the Member edge of a Insurance.
func (c *InsuranceClient) QueryMember(i *Insurance) *MemberQuery {
	query := &MemberQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(insurance.Table, insurance.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, insurance.MemberTable, insurance.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHospital queries the Hospital edge of a Insurance.
func (c *InsuranceClient) QueryHospital(i *Insurance) *HospitalQuery {
	query := &HospitalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(insurance.Table, insurance.FieldID, id),
			sqlgraph.To(hospital.Table, hospital.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, insurance.HospitalTable, insurance.HospitalColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOfficer queries the Officer edge of a Insurance.
func (c *InsuranceClient) QueryOfficer(i *Insurance) *OfficerQuery {
	query := &OfficerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(insurance.Table, insurance.FieldID, id),
			sqlgraph.To(officer.Table, officer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, insurance.OfficerTable, insurance.OfficerColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the Product edge of a Insurance.
func (c *InsuranceClient) QueryProduct(i *Insurance) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(insurance.Table, insurance.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, insurance.ProductTable, insurance.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInsurancePayment queries the insurance_payment edge of a Insurance.
func (c *InsuranceClient) QueryInsurancePayment(i *Insurance) *PaymentQuery {
	query := &PaymentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(insurance.Table, insurance.FieldID, id),
			sqlgraph.To(payment.Table, payment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, insurance.InsurancePaymentTable, insurance.InsurancePaymentColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InsuranceClient) Hooks() []Hook {
	return c.hooks.Insurance
}

// MemberClient is a client for the Member schema.
type MemberClient struct {
	config
}

// NewMemberClient returns a client for the Member from the given config.
func NewMemberClient(c config) *MemberClient {
	return &MemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `member.Hooks(f(g(h())))`.
func (c *MemberClient) Use(hooks ...Hook) {
	c.hooks.Member = append(c.hooks.Member, hooks...)
}

// Create returns a create builder for Member.
func (c *MemberClient) Create() *MemberCreate {
	mutation := newMemberMutation(c.config, OpCreate)
	return &MemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Member.
func (c *MemberClient) Update() *MemberUpdate {
	mutation := newMemberMutation(c.config, OpUpdate)
	return &MemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberClient) UpdateOne(m *Member) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMember(m))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberClient) UpdateOneID(id int) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMemberID(id))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Member.
func (c *MemberClient) Delete() *MemberDelete {
	mutation := newMemberMutation(c.config, OpDelete)
	return &MemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MemberClient) DeleteOne(m *Member) *MemberDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MemberClient) DeleteOneID(id int) *MemberDeleteOne {
	builder := c.Delete().Where(member.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberDeleteOne{builder}
}

// Create returns a query builder for Member.
func (c *MemberClient) Query() *MemberQuery {
	return &MemberQuery{config: c.config}
}

// Get returns a Member entity by its id.
func (c *MemberClient) Get(ctx context.Context, id int) (*Member, error) {
	return c.Query().Where(member.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberClient) GetX(ctx context.Context, id int) *Member {
	m, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return m
}

// QueryMemberInsurance queries the member_insurance edge of a Member.
func (c *MemberClient) QueryMemberInsurance(m *Member) *InsuranceQuery {
	query := &InsuranceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(insurance.Table, insurance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberInsuranceTable, member.MemberInsuranceColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberPayment queries the member_payment edge of a Member.
func (c *MemberClient) QueryMemberPayment(m *Member) *PaymentQuery {
	query := &PaymentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(payment.Table, payment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberPaymentTable, member.MemberPaymentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberInquiry queries the member_inquiry edge of a Member.
func (c *MemberClient) QueryMemberInquiry(m *Member) *InquiryQuery {
	query := &InquiryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(inquiry.Table, inquiry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberInquiryTable, member.MemberInquiryColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberClient) Hooks() []Hook {
	return c.hooks.Member
}

// MoneyTransferClient is a client for the MoneyTransfer schema.
type MoneyTransferClient struct {
	config
}

// NewMoneyTransferClient returns a client for the MoneyTransfer from the given config.
func NewMoneyTransferClient(c config) *MoneyTransferClient {
	return &MoneyTransferClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `moneytransfer.Hooks(f(g(h())))`.
func (c *MoneyTransferClient) Use(hooks ...Hook) {
	c.hooks.MoneyTransfer = append(c.hooks.MoneyTransfer, hooks...)
}

// Create returns a create builder for MoneyTransfer.
func (c *MoneyTransferClient) Create() *MoneyTransferCreate {
	mutation := newMoneyTransferMutation(c.config, OpCreate)
	return &MoneyTransferCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for MoneyTransfer.
func (c *MoneyTransferClient) Update() *MoneyTransferUpdate {
	mutation := newMoneyTransferMutation(c.config, OpUpdate)
	return &MoneyTransferUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MoneyTransferClient) UpdateOne(mt *MoneyTransfer) *MoneyTransferUpdateOne {
	mutation := newMoneyTransferMutation(c.config, OpUpdateOne, withMoneyTransfer(mt))
	return &MoneyTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MoneyTransferClient) UpdateOneID(id int) *MoneyTransferUpdateOne {
	mutation := newMoneyTransferMutation(c.config, OpUpdateOne, withMoneyTransferID(id))
	return &MoneyTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MoneyTransfer.
func (c *MoneyTransferClient) Delete() *MoneyTransferDelete {
	mutation := newMoneyTransferMutation(c.config, OpDelete)
	return &MoneyTransferDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MoneyTransferClient) DeleteOne(mt *MoneyTransfer) *MoneyTransferDeleteOne {
	return c.DeleteOneID(mt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MoneyTransferClient) DeleteOneID(id int) *MoneyTransferDeleteOne {
	builder := c.Delete().Where(moneytransfer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MoneyTransferDeleteOne{builder}
}

// Create returns a query builder for MoneyTransfer.
func (c *MoneyTransferClient) Query() *MoneyTransferQuery {
	return &MoneyTransferQuery{config: c.config}
}

// Get returns a MoneyTransfer entity by its id.
func (c *MoneyTransferClient) Get(ctx context.Context, id int) (*MoneyTransfer, error) {
	return c.Query().Where(moneytransfer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MoneyTransferClient) GetX(ctx context.Context, id int) *MoneyTransfer {
	mt, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return mt
}

// QueryMoneytransferPayment queries the moneytransfer_payment edge of a MoneyTransfer.
func (c *MoneyTransferClient) QueryMoneytransferPayment(mt *MoneyTransfer) *PaymentQuery {
	query := &PaymentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moneytransfer.Table, moneytransfer.FieldID, id),
			sqlgraph.To(payment.Table, payment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, moneytransfer.MoneytransferPaymentTable, moneytransfer.MoneytransferPaymentColumn),
		)
		fromV = sqlgraph.Neighbors(mt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MoneyTransferClient) Hooks() []Hook {
	return c.hooks.MoneyTransfer
}

// OfficerClient is a client for the Officer schema.
type OfficerClient struct {
	config
}

// NewOfficerClient returns a client for the Officer from the given config.
func NewOfficerClient(c config) *OfficerClient {
	return &OfficerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `officer.Hooks(f(g(h())))`.
func (c *OfficerClient) Use(hooks ...Hook) {
	c.hooks.Officer = append(c.hooks.Officer, hooks...)
}

// Create returns a create builder for Officer.
func (c *OfficerClient) Create() *OfficerCreate {
	mutation := newOfficerMutation(c.config, OpCreate)
	return &OfficerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Officer.
func (c *OfficerClient) Update() *OfficerUpdate {
	mutation := newOfficerMutation(c.config, OpUpdate)
	return &OfficerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OfficerClient) UpdateOne(o *Officer) *OfficerUpdateOne {
	mutation := newOfficerMutation(c.config, OpUpdateOne, withOfficer(o))
	return &OfficerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OfficerClient) UpdateOneID(id int) *OfficerUpdateOne {
	mutation := newOfficerMutation(c.config, OpUpdateOne, withOfficerID(id))
	return &OfficerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Officer.
func (c *OfficerClient) Delete() *OfficerDelete {
	mutation := newOfficerMutation(c.config, OpDelete)
	return &OfficerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *OfficerClient) DeleteOne(o *Officer) *OfficerDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *OfficerClient) DeleteOneID(id int) *OfficerDeleteOne {
	builder := c.Delete().Where(officer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OfficerDeleteOne{builder}
}

// Create returns a query builder for Officer.
func (c *OfficerClient) Query() *OfficerQuery {
	return &OfficerQuery{config: c.config}
}

// Get returns a Officer entity by its id.
func (c *OfficerClient) Get(ctx context.Context, id int) (*Officer, error) {
	return c.Query().Where(officer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OfficerClient) GetX(ctx context.Context, id int) *Officer {
	o, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return o
}

// QueryOfficers queries the officers edge of a Officer.
func (c *OfficerClient) QueryOfficers(o *Officer) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(officer.Table, officer.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, officer.OfficersTable, officer.OfficersColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOfficerInsurance queries the officer_insurance edge of a Officer.
func (c *OfficerClient) QueryOfficerInsurance(o *Officer) *InsuranceQuery {
	query := &InsuranceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(officer.Table, officer.FieldID, id),
			sqlgraph.To(insurance.Table, insurance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, officer.OfficerInsuranceTable, officer.OfficerInsuranceColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOfficerInquiry queries the officer_inquiry edge of a Officer.
func (c *OfficerClient) QueryOfficerInquiry(o *Officer) *InquiryQuery {
	query := &InquiryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(officer.Table, officer.FieldID, id),
			sqlgraph.To(inquiry.Table, inquiry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, officer.OfficerInquiryTable, officer.OfficerInquiryColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OfficerClient) Hooks() []Hook {
	return c.hooks.Officer
}

// PaymentClient is a client for the Payment schema.
type PaymentClient struct {
	config
}

// NewPaymentClient returns a client for the Payment from the given config.
func NewPaymentClient(c config) *PaymentClient {
	return &PaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payment.Hooks(f(g(h())))`.
func (c *PaymentClient) Use(hooks ...Hook) {
	c.hooks.Payment = append(c.hooks.Payment, hooks...)
}

// Create returns a create builder for Payment.
func (c *PaymentClient) Create() *PaymentCreate {
	mutation := newPaymentMutation(c.config, OpCreate)
	return &PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Payment.
func (c *PaymentClient) Update() *PaymentUpdate {
	mutation := newPaymentMutation(c.config, OpUpdate)
	return &PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentClient) UpdateOne(pa *Payment) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPayment(pa))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentClient) UpdateOneID(id int) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPaymentID(id))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payment.
func (c *PaymentClient) Delete() *PaymentDelete {
	mutation := newPaymentMutation(c.config, OpDelete)
	return &PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PaymentClient) DeleteOne(pa *Payment) *PaymentDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PaymentClient) DeleteOneID(id int) *PaymentDeleteOne {
	builder := c.Delete().Where(payment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentDeleteOne{builder}
}

// Create returns a query builder for Payment.
func (c *PaymentClient) Query() *PaymentQuery {
	return &PaymentQuery{config: c.config}
}

// Get returns a Payment entity by its id.
func (c *PaymentClient) Get(ctx context.Context, id int) (*Payment, error) {
	return c.Query().Where(payment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentClient) GetX(ctx context.Context, id int) *Payment {
	pa, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pa
}

// QueryInsurance queries the Insurance edge of a Payment.
func (c *PaymentClient) QueryInsurance(pa *Payment) *InsuranceQuery {
	query := &InsuranceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payment.Table, payment.FieldID, id),
			sqlgraph.To(insurance.Table, insurance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payment.InsuranceTable, payment.InsuranceColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMoneyTransfer queries the MoneyTransfer edge of a Payment.
func (c *PaymentClient) QueryMoneyTransfer(pa *Payment) *MoneyTransferQuery {
	query := &MoneyTransferQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payment.Table, payment.FieldID, id),
			sqlgraph.To(moneytransfer.Table, moneytransfer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payment.MoneyTransferTable, payment.MoneyTransferColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBank queries the Bank edge of a Payment.
func (c *PaymentClient) QueryBank(pa *Payment) *BankQuery {
	query := &BankQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payment.Table, payment.FieldID, id),
			sqlgraph.To(bank.Table, bank.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payment.BankTable, payment.BankColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMember queries the Member edge of a Payment.
func (c *PaymentClient) QueryMember(pa *Payment) *MemberQuery {
	query := &MemberQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payment.Table, payment.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payment.MemberTable, payment.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PaymentClient) Hooks() []Hook {
	return c.hooks.Payment
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Create returns a create builder for Product.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProductClient) DeleteOneID(id int) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Create returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{config: c.config}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int) *Product {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// QueryGender queries the Gender edge of a Product.
func (c *ProductClient) QueryGender(pr *Product) *GenderQuery {
	query := &GenderQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(gender.Table, gender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.GenderTable, product.GenderColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGoupOfAge queries the Goup_Of_Age edge of a Product.
func (c *ProductClient) QueryGoupOfAge(pr *Product) *GroupOfAgeQuery {
	query := &GroupOfAgeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(groupofage.Table, groupofage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.GoupOfAgeTable, product.GoupOfAgeColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOfficer queries the Officer edge of a Product.
func (c *ProductClient) QueryOfficer(pr *Product) *OfficerQuery {
	query := &OfficerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(officer.Table, officer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.OfficerTable, product.OfficerColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductInsurance queries the product_insurance edge of a Product.
func (c *ProductClient) QueryProductInsurance(pr *Product) *InsuranceQuery {
	query := &InsuranceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(insurance.Table, insurance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.ProductInsuranceTable, product.ProductInsuranceColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductInquiry queries the product_inquiry edge of a Product.
func (c *ProductClient) QueryProductInquiry(pr *Product) *InquiryQuery {
	query := &InquiryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(inquiry.Table, inquiry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.ProductInquiryTable, product.ProductInquiryColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}
