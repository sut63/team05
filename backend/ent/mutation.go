// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/sut63/team05/ent/gender"
	"github.com/sut63/team05/ent/groupofage"
	"github.com/sut63/team05/ent/hospital"
	"github.com/sut63/team05/ent/insurance"
	"github.com/sut63/team05/ent/member"
	"github.com/sut63/team05/ent/officer"
	"github.com/sut63/team05/ent/product"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGender     = "Gender"
	TypeGroupOfAge = "GroupOfAge"
	TypeHospital   = "Hospital"
	TypeInsurance  = "Insurance"
	TypeMember     = "Member"
	TypeOfficer    = "Officer"
	TypeProduct    = "Product"
)

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op             Op
	typ            string
	id             *int
	gender_name    *string
	clearedFields  map[string]struct{}
	genders        map[int]struct{}
	removedgenders map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGenderName sets the gender_name field.
func (m *GenderMutation) SetGenderName(s string) {
	m.gender_name = &s
}

// GenderName returns the gender_name value in the mutation.
func (m *GenderMutation) GenderName() (r string, exists bool) {
	v := m.gender_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderName returns the old gender_name value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGenderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderName: %w", err)
	}
	return oldValue.GenderName, nil
}

// ResetGenderName reset all changes of the "gender_name" field.
func (m *GenderMutation) ResetGenderName() {
	m.gender_name = nil
}

// AddGenderIDs adds the genders edge to Product by ids.
func (m *GenderMutation) AddGenderIDs(ids ...int) {
	if m.genders == nil {
		m.genders = make(map[int]struct{})
	}
	for i := range ids {
		m.genders[ids[i]] = struct{}{}
	}
}

// RemoveGenderIDs removes the genders edge to Product by ids.
func (m *GenderMutation) RemoveGenderIDs(ids ...int) {
	if m.removedgenders == nil {
		m.removedgenders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgenders[ids[i]] = struct{}{}
	}
}

// RemovedGenders returns the removed ids of genders.
func (m *GenderMutation) RemovedGendersIDs() (ids []int) {
	for id := range m.removedgenders {
		ids = append(ids, id)
	}
	return
}

// GendersIDs returns the genders ids in the mutation.
func (m *GenderMutation) GendersIDs() (ids []int) {
	for id := range m.genders {
		ids = append(ids, id)
	}
	return
}

// ResetGenders reset all changes of the "genders" edge.
func (m *GenderMutation) ResetGenders() {
	m.genders = nil
	m.removedgenders = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.gender_name != nil {
		fields = append(fields, gender.FieldGenderName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGenderName:
		return m.GenderName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGenderName:
		return m.OldGenderName(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGenderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderName(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGenderName:
		m.ResetGenderName()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.genders != nil {
		edges = append(edges, gender.EdgeGenders)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGenders:
		ids := make([]ent.Value, 0, len(m.genders))
		for id := range m.genders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenders != nil {
		edges = append(edges, gender.EdgeGenders)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGenders:
		ids := make([]ent.Value, 0, len(m.removedgenders))
		for id := range m.removedgenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeGenders:
		m.ResetGenders()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// GroupOfAgeMutation represents an operation that mutate the GroupOfAges
// nodes in the graph.
type GroupOfAgeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	group_of_age_name *string
	group_of_age_age  *string
	clearedFields     map[string]struct{}
	gropages          map[int]struct{}
	removedgropages   map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*GroupOfAge, error)
}

var _ ent.Mutation = (*GroupOfAgeMutation)(nil)

// groupofageOption allows to manage the mutation configuration using functional options.
type groupofageOption func(*GroupOfAgeMutation)

// newGroupOfAgeMutation creates new mutation for $n.Name.
func newGroupOfAgeMutation(c config, op Op, opts ...groupofageOption) *GroupOfAgeMutation {
	m := &GroupOfAgeMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupOfAge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupOfAgeID sets the id field of the mutation.
func withGroupOfAgeID(id int) groupofageOption {
	return func(m *GroupOfAgeMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupOfAge
		)
		m.oldValue = func(ctx context.Context) (*GroupOfAge, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupOfAge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupOfAge sets the old GroupOfAge of the mutation.
func withGroupOfAge(node *GroupOfAge) groupofageOption {
	return func(m *GroupOfAgeMutation) {
		m.oldValue = func(context.Context) (*GroupOfAge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupOfAgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupOfAgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GroupOfAgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGroupOfAgeName sets the group_of_age_name field.
func (m *GroupOfAgeMutation) SetGroupOfAgeName(s string) {
	m.group_of_age_name = &s
}

// GroupOfAgeName returns the group_of_age_name value in the mutation.
func (m *GroupOfAgeMutation) GroupOfAgeName() (r string, exists bool) {
	v := m.group_of_age_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupOfAgeName returns the old group_of_age_name value of the GroupOfAge.
// If the GroupOfAge object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GroupOfAgeMutation) OldGroupOfAgeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGroupOfAgeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGroupOfAgeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupOfAgeName: %w", err)
	}
	return oldValue.GroupOfAgeName, nil
}

// ResetGroupOfAgeName reset all changes of the "group_of_age_name" field.
func (m *GroupOfAgeMutation) ResetGroupOfAgeName() {
	m.group_of_age_name = nil
}

// SetGroupOfAgeAge sets the group_of_age_age field.
func (m *GroupOfAgeMutation) SetGroupOfAgeAge(s string) {
	m.group_of_age_age = &s
}

// GroupOfAgeAge returns the group_of_age_age value in the mutation.
func (m *GroupOfAgeMutation) GroupOfAgeAge() (r string, exists bool) {
	v := m.group_of_age_age
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupOfAgeAge returns the old group_of_age_age value of the GroupOfAge.
// If the GroupOfAge object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GroupOfAgeMutation) OldGroupOfAgeAge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGroupOfAgeAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGroupOfAgeAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupOfAgeAge: %w", err)
	}
	return oldValue.GroupOfAgeAge, nil
}

// ResetGroupOfAgeAge reset all changes of the "group_of_age_age" field.
func (m *GroupOfAgeMutation) ResetGroupOfAgeAge() {
	m.group_of_age_age = nil
}

// AddGropageIDs adds the gropages edge to Product by ids.
func (m *GroupOfAgeMutation) AddGropageIDs(ids ...int) {
	if m.gropages == nil {
		m.gropages = make(map[int]struct{})
	}
	for i := range ids {
		m.gropages[ids[i]] = struct{}{}
	}
}

// RemoveGropageIDs removes the gropages edge to Product by ids.
func (m *GroupOfAgeMutation) RemoveGropageIDs(ids ...int) {
	if m.removedgropages == nil {
		m.removedgropages = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgropages[ids[i]] = struct{}{}
	}
}

// RemovedGropages returns the removed ids of gropages.
func (m *GroupOfAgeMutation) RemovedGropagesIDs() (ids []int) {
	for id := range m.removedgropages {
		ids = append(ids, id)
	}
	return
}

// GropagesIDs returns the gropages ids in the mutation.
func (m *GroupOfAgeMutation) GropagesIDs() (ids []int) {
	for id := range m.gropages {
		ids = append(ids, id)
	}
	return
}

// ResetGropages reset all changes of the "gropages" edge.
func (m *GroupOfAgeMutation) ResetGropages() {
	m.gropages = nil
	m.removedgropages = nil
}

// Op returns the operation name.
func (m *GroupOfAgeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GroupOfAge).
func (m *GroupOfAgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GroupOfAgeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.group_of_age_name != nil {
		fields = append(fields, groupofage.FieldGroupOfAgeName)
	}
	if m.group_of_age_age != nil {
		fields = append(fields, groupofage.FieldGroupOfAgeAge)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GroupOfAgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupofage.FieldGroupOfAgeName:
		return m.GroupOfAgeName()
	case groupofage.FieldGroupOfAgeAge:
		return m.GroupOfAgeAge()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GroupOfAgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupofage.FieldGroupOfAgeName:
		return m.OldGroupOfAgeName(ctx)
	case groupofage.FieldGroupOfAgeAge:
		return m.OldGroupOfAgeAge(ctx)
	}
	return nil, fmt.Errorf("unknown GroupOfAge field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroupOfAgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupofage.FieldGroupOfAgeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupOfAgeName(v)
		return nil
	case groupofage.FieldGroupOfAgeAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupOfAgeAge(v)
		return nil
	}
	return fmt.Errorf("unknown GroupOfAge field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GroupOfAgeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GroupOfAgeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroupOfAgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupOfAge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GroupOfAgeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GroupOfAgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupOfAgeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroupOfAge nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GroupOfAgeMutation) ResetField(name string) error {
	switch name {
	case groupofage.FieldGroupOfAgeName:
		m.ResetGroupOfAgeName()
		return nil
	case groupofage.FieldGroupOfAgeAge:
		m.ResetGroupOfAgeAge()
		return nil
	}
	return fmt.Errorf("unknown GroupOfAge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GroupOfAgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.gropages != nil {
		edges = append(edges, groupofage.EdgeGropages)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GroupOfAgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupofage.EdgeGropages:
		ids := make([]ent.Value, 0, len(m.gropages))
		for id := range m.gropages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GroupOfAgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgropages != nil {
		edges = append(edges, groupofage.EdgeGropages)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GroupOfAgeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case groupofage.EdgeGropages:
		ids := make([]ent.Value, 0, len(m.removedgropages))
		for id := range m.removedgropages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GroupOfAgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GroupOfAgeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GroupOfAgeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupOfAge unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GroupOfAgeMutation) ResetEdge(name string) error {
	switch name {
	case groupofage.EdgeGropages:
		m.ResetGropages()
		return nil
	}
	return fmt.Errorf("unknown GroupOfAge edge %s", name)
}

// HospitalMutation represents an operation that mutate the Hospitals
// nodes in the graph.
type HospitalMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	hospital_name             *string
	clearedFields             map[string]struct{}
	hospital_insurance        map[int]struct{}
	removedhospital_insurance map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Hospital, error)
}

var _ ent.Mutation = (*HospitalMutation)(nil)

// hospitalOption allows to manage the mutation configuration using functional options.
type hospitalOption func(*HospitalMutation)

// newHospitalMutation creates new mutation for $n.Name.
func newHospitalMutation(c config, op Op, opts ...hospitalOption) *HospitalMutation {
	m := &HospitalMutation{
		config:        c,
		op:            op,
		typ:           TypeHospital,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHospitalID sets the id field of the mutation.
func withHospitalID(id int) hospitalOption {
	return func(m *HospitalMutation) {
		var (
			err   error
			once  sync.Once
			value *Hospital
		)
		m.oldValue = func(ctx context.Context) (*Hospital, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hospital.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHospital sets the old Hospital of the mutation.
func withHospital(node *Hospital) hospitalOption {
	return func(m *HospitalMutation) {
		m.oldValue = func(context.Context) (*Hospital, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HospitalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HospitalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HospitalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHospitalName sets the hospital_name field.
func (m *HospitalMutation) SetHospitalName(s string) {
	m.hospital_name = &s
}

// HospitalName returns the hospital_name value in the mutation.
func (m *HospitalMutation) HospitalName() (r string, exists bool) {
	v := m.hospital_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHospitalName returns the old hospital_name value of the Hospital.
// If the Hospital object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HospitalMutation) OldHospitalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHospitalName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHospitalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHospitalName: %w", err)
	}
	return oldValue.HospitalName, nil
}

// ResetHospitalName reset all changes of the "hospital_name" field.
func (m *HospitalMutation) ResetHospitalName() {
	m.hospital_name = nil
}

// AddHospitalInsuranceIDs adds the hospital_insurance edge to Insurance by ids.
func (m *HospitalMutation) AddHospitalInsuranceIDs(ids ...int) {
	if m.hospital_insurance == nil {
		m.hospital_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.hospital_insurance[ids[i]] = struct{}{}
	}
}

// RemoveHospitalInsuranceIDs removes the hospital_insurance edge to Insurance by ids.
func (m *HospitalMutation) RemoveHospitalInsuranceIDs(ids ...int) {
	if m.removedhospital_insurance == nil {
		m.removedhospital_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhospital_insurance[ids[i]] = struct{}{}
	}
}

// RemovedHospitalInsurance returns the removed ids of hospital_insurance.
func (m *HospitalMutation) RemovedHospitalInsuranceIDs() (ids []int) {
	for id := range m.removedhospital_insurance {
		ids = append(ids, id)
	}
	return
}

// HospitalInsuranceIDs returns the hospital_insurance ids in the mutation.
func (m *HospitalMutation) HospitalInsuranceIDs() (ids []int) {
	for id := range m.hospital_insurance {
		ids = append(ids, id)
	}
	return
}

// ResetHospitalInsurance reset all changes of the "hospital_insurance" edge.
func (m *HospitalMutation) ResetHospitalInsurance() {
	m.hospital_insurance = nil
	m.removedhospital_insurance = nil
}

// Op returns the operation name.
func (m *HospitalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hospital).
func (m *HospitalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HospitalMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.hospital_name != nil {
		fields = append(fields, hospital.FieldHospitalName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HospitalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hospital.FieldHospitalName:
		return m.HospitalName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HospitalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hospital.FieldHospitalName:
		return m.OldHospitalName(ctx)
	}
	return nil, fmt.Errorf("unknown Hospital field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HospitalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hospital.FieldHospitalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHospitalName(v)
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HospitalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HospitalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HospitalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HospitalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HospitalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HospitalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hospital nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HospitalMutation) ResetField(name string) error {
	switch name {
	case hospital.FieldHospitalName:
		m.ResetHospitalName()
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HospitalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hospital_insurance != nil {
		edges = append(edges, hospital.EdgeHospitalInsurance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HospitalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospitalInsurance:
		ids := make([]ent.Value, 0, len(m.hospital_insurance))
		for id := range m.hospital_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HospitalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhospital_insurance != nil {
		edges = append(edges, hospital.EdgeHospitalInsurance)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HospitalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospitalInsurance:
		ids := make([]ent.Value, 0, len(m.removedhospital_insurance))
		for id := range m.removedhospital_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HospitalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HospitalMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HospitalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HospitalMutation) ResetEdge(name string) error {
	switch name {
	case hospital.EdgeHospitalInsurance:
		m.ResetHospitalInsurance()
		return nil
	}
	return fmt.Errorf("unknown Hospital edge %s", name)
}

// InsuranceMutation represents an operation that mutate the Insurances
// nodes in the graph.
type InsuranceMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	insurance_address       *string
	insurance_insurer       *string
	insurance_time_buy      *time.Time
	insurance_time_firstpay *time.Time
	clearedFields           map[string]struct{}
	_Member                 *int
	cleared_Member          bool
	_Hospital               *int
	cleared_Hospital        bool
	_Officer                *int
	cleared_Officer         bool
	_Product                *int
	cleared_Product         bool
	done                    bool
	oldValue                func(context.Context) (*Insurance, error)
}

var _ ent.Mutation = (*InsuranceMutation)(nil)

// insuranceOption allows to manage the mutation configuration using functional options.
type insuranceOption func(*InsuranceMutation)

// newInsuranceMutation creates new mutation for $n.Name.
func newInsuranceMutation(c config, op Op, opts ...insuranceOption) *InsuranceMutation {
	m := &InsuranceMutation{
		config:        c,
		op:            op,
		typ:           TypeInsurance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInsuranceID sets the id field of the mutation.
func withInsuranceID(id int) insuranceOption {
	return func(m *InsuranceMutation) {
		var (
			err   error
			once  sync.Once
			value *Insurance
		)
		m.oldValue = func(ctx context.Context) (*Insurance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Insurance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInsurance sets the old Insurance of the mutation.
func withInsurance(node *Insurance) insuranceOption {
	return func(m *InsuranceMutation) {
		m.oldValue = func(context.Context) (*Insurance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InsuranceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InsuranceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InsuranceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInsuranceAddress sets the insurance_address field.
func (m *InsuranceMutation) SetInsuranceAddress(s string) {
	m.insurance_address = &s
}

// InsuranceAddress returns the insurance_address value in the mutation.
func (m *InsuranceMutation) InsuranceAddress() (r string, exists bool) {
	v := m.insurance_address
	if v == nil {
		return
	}
	return *v, true
}

// OldInsuranceAddress returns the old insurance_address value of the Insurance.
// If the Insurance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InsuranceMutation) OldInsuranceAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsuranceAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsuranceAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsuranceAddress: %w", err)
	}
	return oldValue.InsuranceAddress, nil
}

// ResetInsuranceAddress reset all changes of the "insurance_address" field.
func (m *InsuranceMutation) ResetInsuranceAddress() {
	m.insurance_address = nil
}

// SetInsuranceInsurer sets the insurance_insurer field.
func (m *InsuranceMutation) SetInsuranceInsurer(s string) {
	m.insurance_insurer = &s
}

// InsuranceInsurer returns the insurance_insurer value in the mutation.
func (m *InsuranceMutation) InsuranceInsurer() (r string, exists bool) {
	v := m.insurance_insurer
	if v == nil {
		return
	}
	return *v, true
}

// OldInsuranceInsurer returns the old insurance_insurer value of the Insurance.
// If the Insurance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InsuranceMutation) OldInsuranceInsurer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsuranceInsurer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsuranceInsurer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsuranceInsurer: %w", err)
	}
	return oldValue.InsuranceInsurer, nil
}

// ResetInsuranceInsurer reset all changes of the "insurance_insurer" field.
func (m *InsuranceMutation) ResetInsuranceInsurer() {
	m.insurance_insurer = nil
}

// SetInsuranceTimeBuy sets the insurance_time_buy field.
func (m *InsuranceMutation) SetInsuranceTimeBuy(t time.Time) {
	m.insurance_time_buy = &t
}

// InsuranceTimeBuy returns the insurance_time_buy value in the mutation.
func (m *InsuranceMutation) InsuranceTimeBuy() (r time.Time, exists bool) {
	v := m.insurance_time_buy
	if v == nil {
		return
	}
	return *v, true
}

// OldInsuranceTimeBuy returns the old insurance_time_buy value of the Insurance.
// If the Insurance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InsuranceMutation) OldInsuranceTimeBuy(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsuranceTimeBuy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsuranceTimeBuy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsuranceTimeBuy: %w", err)
	}
	return oldValue.InsuranceTimeBuy, nil
}

// ResetInsuranceTimeBuy reset all changes of the "insurance_time_buy" field.
func (m *InsuranceMutation) ResetInsuranceTimeBuy() {
	m.insurance_time_buy = nil
}

// SetInsuranceTimeFirstpay sets the insurance_time_firstpay field.
func (m *InsuranceMutation) SetInsuranceTimeFirstpay(t time.Time) {
	m.insurance_time_firstpay = &t
}

// InsuranceTimeFirstpay returns the insurance_time_firstpay value in the mutation.
func (m *InsuranceMutation) InsuranceTimeFirstpay() (r time.Time, exists bool) {
	v := m.insurance_time_firstpay
	if v == nil {
		return
	}
	return *v, true
}

// OldInsuranceTimeFirstpay returns the old insurance_time_firstpay value of the Insurance.
// If the Insurance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InsuranceMutation) OldInsuranceTimeFirstpay(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsuranceTimeFirstpay is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsuranceTimeFirstpay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsuranceTimeFirstpay: %w", err)
	}
	return oldValue.InsuranceTimeFirstpay, nil
}

// ResetInsuranceTimeFirstpay reset all changes of the "insurance_time_firstpay" field.
func (m *InsuranceMutation) ResetInsuranceTimeFirstpay() {
	m.insurance_time_firstpay = nil
}

// SetMemberID sets the Member edge to Member by id.
func (m *InsuranceMutation) SetMemberID(id int) {
	m._Member = &id
}

// ClearMember clears the Member edge to Member.
func (m *InsuranceMutation) ClearMember() {
	m.cleared_Member = true
}

// MemberCleared returns if the edge Member was cleared.
func (m *InsuranceMutation) MemberCleared() bool {
	return m.cleared_Member
}

// MemberID returns the Member id in the mutation.
func (m *InsuranceMutation) MemberID() (id int, exists bool) {
	if m._Member != nil {
		return *m._Member, true
	}
	return
}

// MemberIDs returns the Member ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *InsuranceMutation) MemberIDs() (ids []int) {
	if id := m._Member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember reset all changes of the "Member" edge.
func (m *InsuranceMutation) ResetMember() {
	m._Member = nil
	m.cleared_Member = false
}

// SetHospitalID sets the Hospital edge to Hospital by id.
func (m *InsuranceMutation) SetHospitalID(id int) {
	m._Hospital = &id
}

// ClearHospital clears the Hospital edge to Hospital.
func (m *InsuranceMutation) ClearHospital() {
	m.cleared_Hospital = true
}

// HospitalCleared returns if the edge Hospital was cleared.
func (m *InsuranceMutation) HospitalCleared() bool {
	return m.cleared_Hospital
}

// HospitalID returns the Hospital id in the mutation.
func (m *InsuranceMutation) HospitalID() (id int, exists bool) {
	if m._Hospital != nil {
		return *m._Hospital, true
	}
	return
}

// HospitalIDs returns the Hospital ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HospitalID instead. It exists only for internal usage by the builders.
func (m *InsuranceMutation) HospitalIDs() (ids []int) {
	if id := m._Hospital; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHospital reset all changes of the "Hospital" edge.
func (m *InsuranceMutation) ResetHospital() {
	m._Hospital = nil
	m.cleared_Hospital = false
}

// SetOfficerID sets the Officer edge to Officer by id.
func (m *InsuranceMutation) SetOfficerID(id int) {
	m._Officer = &id
}

// ClearOfficer clears the Officer edge to Officer.
func (m *InsuranceMutation) ClearOfficer() {
	m.cleared_Officer = true
}

// OfficerCleared returns if the edge Officer was cleared.
func (m *InsuranceMutation) OfficerCleared() bool {
	return m.cleared_Officer
}

// OfficerID returns the Officer id in the mutation.
func (m *InsuranceMutation) OfficerID() (id int, exists bool) {
	if m._Officer != nil {
		return *m._Officer, true
	}
	return
}

// OfficerIDs returns the Officer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OfficerID instead. It exists only for internal usage by the builders.
func (m *InsuranceMutation) OfficerIDs() (ids []int) {
	if id := m._Officer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOfficer reset all changes of the "Officer" edge.
func (m *InsuranceMutation) ResetOfficer() {
	m._Officer = nil
	m.cleared_Officer = false
}

// SetProductID sets the Product edge to Product by id.
func (m *InsuranceMutation) SetProductID(id int) {
	m._Product = &id
}

// ClearProduct clears the Product edge to Product.
func (m *InsuranceMutation) ClearProduct() {
	m.cleared_Product = true
}

// ProductCleared returns if the edge Product was cleared.
func (m *InsuranceMutation) ProductCleared() bool {
	return m.cleared_Product
}

// ProductID returns the Product id in the mutation.
func (m *InsuranceMutation) ProductID() (id int, exists bool) {
	if m._Product != nil {
		return *m._Product, true
	}
	return
}

// ProductIDs returns the Product ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *InsuranceMutation) ProductIDs() (ids []int) {
	if id := m._Product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct reset all changes of the "Product" edge.
func (m *InsuranceMutation) ResetProduct() {
	m._Product = nil
	m.cleared_Product = false
}

// Op returns the operation name.
func (m *InsuranceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Insurance).
func (m *InsuranceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InsuranceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.insurance_address != nil {
		fields = append(fields, insurance.FieldInsuranceAddress)
	}
	if m.insurance_insurer != nil {
		fields = append(fields, insurance.FieldInsuranceInsurer)
	}
	if m.insurance_time_buy != nil {
		fields = append(fields, insurance.FieldInsuranceTimeBuy)
	}
	if m.insurance_time_firstpay != nil {
		fields = append(fields, insurance.FieldInsuranceTimeFirstpay)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InsuranceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case insurance.FieldInsuranceAddress:
		return m.InsuranceAddress()
	case insurance.FieldInsuranceInsurer:
		return m.InsuranceInsurer()
	case insurance.FieldInsuranceTimeBuy:
		return m.InsuranceTimeBuy()
	case insurance.FieldInsuranceTimeFirstpay:
		return m.InsuranceTimeFirstpay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InsuranceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case insurance.FieldInsuranceAddress:
		return m.OldInsuranceAddress(ctx)
	case insurance.FieldInsuranceInsurer:
		return m.OldInsuranceInsurer(ctx)
	case insurance.FieldInsuranceTimeBuy:
		return m.OldInsuranceTimeBuy(ctx)
	case insurance.FieldInsuranceTimeFirstpay:
		return m.OldInsuranceTimeFirstpay(ctx)
	}
	return nil, fmt.Errorf("unknown Insurance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case insurance.FieldInsuranceAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsuranceAddress(v)
		return nil
	case insurance.FieldInsuranceInsurer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsuranceInsurer(v)
		return nil
	case insurance.FieldInsuranceTimeBuy:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsuranceTimeBuy(v)
		return nil
	case insurance.FieldInsuranceTimeFirstpay:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsuranceTimeFirstpay(v)
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InsuranceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InsuranceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Insurance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InsuranceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InsuranceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InsuranceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Insurance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InsuranceMutation) ResetField(name string) error {
	switch name {
	case insurance.FieldInsuranceAddress:
		m.ResetInsuranceAddress()
		return nil
	case insurance.FieldInsuranceInsurer:
		m.ResetInsuranceInsurer()
		return nil
	case insurance.FieldInsuranceTimeBuy:
		m.ResetInsuranceTimeBuy()
		return nil
	case insurance.FieldInsuranceTimeFirstpay:
		m.ResetInsuranceTimeFirstpay()
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InsuranceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Member != nil {
		edges = append(edges, insurance.EdgeMember)
	}
	if m._Hospital != nil {
		edges = append(edges, insurance.EdgeHospital)
	}
	if m._Officer != nil {
		edges = append(edges, insurance.EdgeOfficer)
	}
	if m._Product != nil {
		edges = append(edges, insurance.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InsuranceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case insurance.EdgeMember:
		if id := m._Member; id != nil {
			return []ent.Value{*id}
		}
	case insurance.EdgeHospital:
		if id := m._Hospital; id != nil {
			return []ent.Value{*id}
		}
	case insurance.EdgeOfficer:
		if id := m._Officer; id != nil {
			return []ent.Value{*id}
		}
	case insurance.EdgeProduct:
		if id := m._Product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InsuranceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InsuranceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InsuranceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Member {
		edges = append(edges, insurance.EdgeMember)
	}
	if m.cleared_Hospital {
		edges = append(edges, insurance.EdgeHospital)
	}
	if m.cleared_Officer {
		edges = append(edges, insurance.EdgeOfficer)
	}
	if m.cleared_Product {
		edges = append(edges, insurance.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InsuranceMutation) EdgeCleared(name string) bool {
	switch name {
	case insurance.EdgeMember:
		return m.cleared_Member
	case insurance.EdgeHospital:
		return m.cleared_Hospital
	case insurance.EdgeOfficer:
		return m.cleared_Officer
	case insurance.EdgeProduct:
		return m.cleared_Product
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InsuranceMutation) ClearEdge(name string) error {
	switch name {
	case insurance.EdgeMember:
		m.ClearMember()
		return nil
	case insurance.EdgeHospital:
		m.ClearHospital()
		return nil
	case insurance.EdgeOfficer:
		m.ClearOfficer()
		return nil
	case insurance.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Insurance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InsuranceMutation) ResetEdge(name string) error {
	switch name {
	case insurance.EdgeMember:
		m.ResetMember()
		return nil
	case insurance.EdgeHospital:
		m.ResetHospital()
		return nil
	case insurance.EdgeOfficer:
		m.ResetOfficer()
		return nil
	case insurance.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Insurance edge %s", name)
}

// MemberMutation represents an operation that mutate the Members
// nodes in the graph.
type MemberMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	member_email            *string
	member_name             *string
	member_password         *string
	clearedFields           map[string]struct{}
	member_insurance        map[int]struct{}
	removedmember_insurance map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Member, error)
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows to manage the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for $n.Name.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the id field of the mutation.
func withMemberID(id int) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMemberEmail sets the member_email field.
func (m *MemberMutation) SetMemberEmail(s string) {
	m.member_email = &s
}

// MemberEmail returns the member_email value in the mutation.
func (m *MemberMutation) MemberEmail() (r string, exists bool) {
	v := m.member_email
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberEmail returns the old member_email value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldMemberEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMemberEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMemberEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberEmail: %w", err)
	}
	return oldValue.MemberEmail, nil
}

// ResetMemberEmail reset all changes of the "member_email" field.
func (m *MemberMutation) ResetMemberEmail() {
	m.member_email = nil
}

// SetMemberName sets the member_name field.
func (m *MemberMutation) SetMemberName(s string) {
	m.member_name = &s
}

// MemberName returns the member_name value in the mutation.
func (m *MemberMutation) MemberName() (r string, exists bool) {
	v := m.member_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberName returns the old member_name value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldMemberName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMemberName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMemberName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberName: %w", err)
	}
	return oldValue.MemberName, nil
}

// ResetMemberName reset all changes of the "member_name" field.
func (m *MemberMutation) ResetMemberName() {
	m.member_name = nil
}

// SetMemberPassword sets the member_password field.
func (m *MemberMutation) SetMemberPassword(s string) {
	m.member_password = &s
}

// MemberPassword returns the member_password value in the mutation.
func (m *MemberMutation) MemberPassword() (r string, exists bool) {
	v := m.member_password
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberPassword returns the old member_password value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldMemberPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMemberPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMemberPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberPassword: %w", err)
	}
	return oldValue.MemberPassword, nil
}

// ResetMemberPassword reset all changes of the "member_password" field.
func (m *MemberMutation) ResetMemberPassword() {
	m.member_password = nil
}

// AddMemberInsuranceIDs adds the member_insurance edge to Insurance by ids.
func (m *MemberMutation) AddMemberInsuranceIDs(ids ...int) {
	if m.member_insurance == nil {
		m.member_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.member_insurance[ids[i]] = struct{}{}
	}
}

// RemoveMemberInsuranceIDs removes the member_insurance edge to Insurance by ids.
func (m *MemberMutation) RemoveMemberInsuranceIDs(ids ...int) {
	if m.removedmember_insurance == nil {
		m.removedmember_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmember_insurance[ids[i]] = struct{}{}
	}
}

// RemovedMemberInsurance returns the removed ids of member_insurance.
func (m *MemberMutation) RemovedMemberInsuranceIDs() (ids []int) {
	for id := range m.removedmember_insurance {
		ids = append(ids, id)
	}
	return
}

// MemberInsuranceIDs returns the member_insurance ids in the mutation.
func (m *MemberMutation) MemberInsuranceIDs() (ids []int) {
	for id := range m.member_insurance {
		ids = append(ids, id)
	}
	return
}

// ResetMemberInsurance reset all changes of the "member_insurance" edge.
func (m *MemberMutation) ResetMemberInsurance() {
	m.member_insurance = nil
	m.removedmember_insurance = nil
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.member_email != nil {
		fields = append(fields, member.FieldMemberEmail)
	}
	if m.member_name != nil {
		fields = append(fields, member.FieldMemberName)
	}
	if m.member_password != nil {
		fields = append(fields, member.FieldMemberPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldMemberEmail:
		return m.MemberEmail()
	case member.FieldMemberName:
		return m.MemberName()
	case member.FieldMemberPassword:
		return m.MemberPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldMemberEmail:
		return m.OldMemberEmail(ctx)
	case member.FieldMemberName:
		return m.OldMemberName(ctx)
	case member.FieldMemberPassword:
		return m.OldMemberPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldMemberEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberEmail(v)
		return nil
	case member.FieldMemberName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberName(v)
		return nil
	case member.FieldMemberPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldMemberEmail:
		m.ResetMemberEmail()
		return nil
	case member.FieldMemberName:
		m.ResetMemberName()
		return nil
	case member.FieldMemberPassword:
		m.ResetMemberPassword()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.member_insurance != nil {
		edges = append(edges, member.EdgeMemberInsurance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberInsurance:
		ids := make([]ent.Value, 0, len(m.member_insurance))
		for id := range m.member_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmember_insurance != nil {
		edges = append(edges, member.EdgeMemberInsurance)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberInsurance:
		ids := make([]ent.Value, 0, len(m.removedmember_insurance))
		for id := range m.removedmember_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberInsurance:
		m.ResetMemberInsurance()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// OfficerMutation represents an operation that mutate the Officers
// nodes in the graph.
type OfficerMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	officer_email            *string
	officer_name             *string
	officer_password         *string
	clearedFields            map[string]struct{}
	officers                 map[int]struct{}
	removedofficers          map[int]struct{}
	officer_insurance        map[int]struct{}
	removedofficer_insurance map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Officer, error)
}

var _ ent.Mutation = (*OfficerMutation)(nil)

// officerOption allows to manage the mutation configuration using functional options.
type officerOption func(*OfficerMutation)

// newOfficerMutation creates new mutation for $n.Name.
func newOfficerMutation(c config, op Op, opts ...officerOption) *OfficerMutation {
	m := &OfficerMutation{
		config:        c,
		op:            op,
		typ:           TypeOfficer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOfficerID sets the id field of the mutation.
func withOfficerID(id int) officerOption {
	return func(m *OfficerMutation) {
		var (
			err   error
			once  sync.Once
			value *Officer
		)
		m.oldValue = func(ctx context.Context) (*Officer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Officer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOfficer sets the old Officer of the mutation.
func withOfficer(node *Officer) officerOption {
	return func(m *OfficerMutation) {
		m.oldValue = func(context.Context) (*Officer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OfficerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OfficerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OfficerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOfficerEmail sets the officer_email field.
func (m *OfficerMutation) SetOfficerEmail(s string) {
	m.officer_email = &s
}

// OfficerEmail returns the officer_email value in the mutation.
func (m *OfficerMutation) OfficerEmail() (r string, exists bool) {
	v := m.officer_email
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficerEmail returns the old officer_email value of the Officer.
// If the Officer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficerMutation) OldOfficerEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOfficerEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOfficerEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficerEmail: %w", err)
	}
	return oldValue.OfficerEmail, nil
}

// ResetOfficerEmail reset all changes of the "officer_email" field.
func (m *OfficerMutation) ResetOfficerEmail() {
	m.officer_email = nil
}

// SetOfficerName sets the officer_name field.
func (m *OfficerMutation) SetOfficerName(s string) {
	m.officer_name = &s
}

// OfficerName returns the officer_name value in the mutation.
func (m *OfficerMutation) OfficerName() (r string, exists bool) {
	v := m.officer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficerName returns the old officer_name value of the Officer.
// If the Officer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficerMutation) OldOfficerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOfficerName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOfficerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficerName: %w", err)
	}
	return oldValue.OfficerName, nil
}

// ResetOfficerName reset all changes of the "officer_name" field.
func (m *OfficerMutation) ResetOfficerName() {
	m.officer_name = nil
}

// SetOfficerPassword sets the officer_password field.
func (m *OfficerMutation) SetOfficerPassword(s string) {
	m.officer_password = &s
}

// OfficerPassword returns the officer_password value in the mutation.
func (m *OfficerMutation) OfficerPassword() (r string, exists bool) {
	v := m.officer_password
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficerPassword returns the old officer_password value of the Officer.
// If the Officer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficerMutation) OldOfficerPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOfficerPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOfficerPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficerPassword: %w", err)
	}
	return oldValue.OfficerPassword, nil
}

// ResetOfficerPassword reset all changes of the "officer_password" field.
func (m *OfficerMutation) ResetOfficerPassword() {
	m.officer_password = nil
}

// AddOfficerIDs adds the officers edge to Product by ids.
func (m *OfficerMutation) AddOfficerIDs(ids ...int) {
	if m.officers == nil {
		m.officers = make(map[int]struct{})
	}
	for i := range ids {
		m.officers[ids[i]] = struct{}{}
	}
}

// RemoveOfficerIDs removes the officers edge to Product by ids.
func (m *OfficerMutation) RemoveOfficerIDs(ids ...int) {
	if m.removedofficers == nil {
		m.removedofficers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedofficers[ids[i]] = struct{}{}
	}
}

// RemovedOfficers returns the removed ids of officers.
func (m *OfficerMutation) RemovedOfficersIDs() (ids []int) {
	for id := range m.removedofficers {
		ids = append(ids, id)
	}
	return
}

// OfficersIDs returns the officers ids in the mutation.
func (m *OfficerMutation) OfficersIDs() (ids []int) {
	for id := range m.officers {
		ids = append(ids, id)
	}
	return
}

// ResetOfficers reset all changes of the "officers" edge.
func (m *OfficerMutation) ResetOfficers() {
	m.officers = nil
	m.removedofficers = nil
}

// AddOfficerInsuranceIDs adds the officer_insurance edge to Insurance by ids.
func (m *OfficerMutation) AddOfficerInsuranceIDs(ids ...int) {
	if m.officer_insurance == nil {
		m.officer_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.officer_insurance[ids[i]] = struct{}{}
	}
}

// RemoveOfficerInsuranceIDs removes the officer_insurance edge to Insurance by ids.
func (m *OfficerMutation) RemoveOfficerInsuranceIDs(ids ...int) {
	if m.removedofficer_insurance == nil {
		m.removedofficer_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.removedofficer_insurance[ids[i]] = struct{}{}
	}
}

// RemovedOfficerInsurance returns the removed ids of officer_insurance.
func (m *OfficerMutation) RemovedOfficerInsuranceIDs() (ids []int) {
	for id := range m.removedofficer_insurance {
		ids = append(ids, id)
	}
	return
}

// OfficerInsuranceIDs returns the officer_insurance ids in the mutation.
func (m *OfficerMutation) OfficerInsuranceIDs() (ids []int) {
	for id := range m.officer_insurance {
		ids = append(ids, id)
	}
	return
}

// ResetOfficerInsurance reset all changes of the "officer_insurance" edge.
func (m *OfficerMutation) ResetOfficerInsurance() {
	m.officer_insurance = nil
	m.removedofficer_insurance = nil
}

// Op returns the operation name.
func (m *OfficerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Officer).
func (m *OfficerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OfficerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.officer_email != nil {
		fields = append(fields, officer.FieldOfficerEmail)
	}
	if m.officer_name != nil {
		fields = append(fields, officer.FieldOfficerName)
	}
	if m.officer_password != nil {
		fields = append(fields, officer.FieldOfficerPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OfficerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case officer.FieldOfficerEmail:
		return m.OfficerEmail()
	case officer.FieldOfficerName:
		return m.OfficerName()
	case officer.FieldOfficerPassword:
		return m.OfficerPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OfficerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case officer.FieldOfficerEmail:
		return m.OldOfficerEmail(ctx)
	case officer.FieldOfficerName:
		return m.OldOfficerName(ctx)
	case officer.FieldOfficerPassword:
		return m.OldOfficerPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Officer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case officer.FieldOfficerEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficerEmail(v)
		return nil
	case officer.FieldOfficerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficerName(v)
		return nil
	case officer.FieldOfficerPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficerPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Officer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OfficerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OfficerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Officer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OfficerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OfficerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OfficerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Officer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OfficerMutation) ResetField(name string) error {
	switch name {
	case officer.FieldOfficerEmail:
		m.ResetOfficerEmail()
		return nil
	case officer.FieldOfficerName:
		m.ResetOfficerName()
		return nil
	case officer.FieldOfficerPassword:
		m.ResetOfficerPassword()
		return nil
	}
	return fmt.Errorf("unknown Officer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OfficerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.officers != nil {
		edges = append(edges, officer.EdgeOfficers)
	}
	if m.officer_insurance != nil {
		edges = append(edges, officer.EdgeOfficerInsurance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OfficerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case officer.EdgeOfficers:
		ids := make([]ent.Value, 0, len(m.officers))
		for id := range m.officers {
			ids = append(ids, id)
		}
		return ids
	case officer.EdgeOfficerInsurance:
		ids := make([]ent.Value, 0, len(m.officer_insurance))
		for id := range m.officer_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OfficerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedofficers != nil {
		edges = append(edges, officer.EdgeOfficers)
	}
	if m.removedofficer_insurance != nil {
		edges = append(edges, officer.EdgeOfficerInsurance)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OfficerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case officer.EdgeOfficers:
		ids := make([]ent.Value, 0, len(m.removedofficers))
		for id := range m.removedofficers {
			ids = append(ids, id)
		}
		return ids
	case officer.EdgeOfficerInsurance:
		ids := make([]ent.Value, 0, len(m.removedofficer_insurance))
		for id := range m.removedofficer_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OfficerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OfficerMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OfficerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Officer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OfficerMutation) ResetEdge(name string) error {
	switch name {
	case officer.EdgeOfficers:
		m.ResetOfficers()
		return nil
	case officer.EdgeOfficerInsurance:
		m.ResetOfficerInsurance()
		return nil
	}
	return fmt.Errorf("unknown Officer edge %s", name)
}

// ProductMutation represents an operation that mutate the Products
// nodes in the graph.
type ProductMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	product_name               *string
	product_price              *int
	addproduct_price           *int
	product_time               *int
	addproduct_time            *int
	product_payment_of_year    *float64
	addproduct_payment_of_year *float64
	clearedFields              map[string]struct{}
	_Gender                    *int
	cleared_Gender             bool
	_Goup_Of_Age               *int
	cleared_Goup_Of_Age        bool
	_Officer                   *int
	cleared_Officer            bool
	product_insurance          map[int]struct{}
	removedproduct_insurance   map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Product, error)
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows to manage the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for $n.Name.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the id field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProductName sets the product_name field.
func (m *ProductMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the product_name value in the mutation.
func (m *ProductMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old product_name value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName reset all changes of the "product_name" field.
func (m *ProductMutation) ResetProductName() {
	m.product_name = nil
}

// SetProductPrice sets the product_price field.
func (m *ProductMutation) SetProductPrice(i int) {
	m.product_price = &i
	m.addproduct_price = nil
}

// ProductPrice returns the product_price value in the mutation.
func (m *ProductMutation) ProductPrice() (r int, exists bool) {
	v := m.product_price
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPrice returns the old product_price value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldProductPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPrice: %w", err)
	}
	return oldValue.ProductPrice, nil
}

// AddProductPrice adds i to product_price.
func (m *ProductMutation) AddProductPrice(i int) {
	if m.addproduct_price != nil {
		*m.addproduct_price += i
	} else {
		m.addproduct_price = &i
	}
}

// AddedProductPrice returns the value that was added to the product_price field in this mutation.
func (m *ProductMutation) AddedProductPrice() (r int, exists bool) {
	v := m.addproduct_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductPrice reset all changes of the "product_price" field.
func (m *ProductMutation) ResetProductPrice() {
	m.product_price = nil
	m.addproduct_price = nil
}

// SetProductTime sets the product_time field.
func (m *ProductMutation) SetProductTime(i int) {
	m.product_time = &i
	m.addproduct_time = nil
}

// ProductTime returns the product_time value in the mutation.
func (m *ProductMutation) ProductTime() (r int, exists bool) {
	v := m.product_time
	if v == nil {
		return
	}
	return *v, true
}

// OldProductTime returns the old product_time value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldProductTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductTime: %w", err)
	}
	return oldValue.ProductTime, nil
}

// AddProductTime adds i to product_time.
func (m *ProductMutation) AddProductTime(i int) {
	if m.addproduct_time != nil {
		*m.addproduct_time += i
	} else {
		m.addproduct_time = &i
	}
}

// AddedProductTime returns the value that was added to the product_time field in this mutation.
func (m *ProductMutation) AddedProductTime() (r int, exists bool) {
	v := m.addproduct_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductTime reset all changes of the "product_time" field.
func (m *ProductMutation) ResetProductTime() {
	m.product_time = nil
	m.addproduct_time = nil
}

// SetProductPaymentOfYear sets the product_payment_of_year field.
func (m *ProductMutation) SetProductPaymentOfYear(f float64) {
	m.product_payment_of_year = &f
	m.addproduct_payment_of_year = nil
}

// ProductPaymentOfYear returns the product_payment_of_year value in the mutation.
func (m *ProductMutation) ProductPaymentOfYear() (r float64, exists bool) {
	v := m.product_payment_of_year
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPaymentOfYear returns the old product_payment_of_year value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldProductPaymentOfYear(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPaymentOfYear is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPaymentOfYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPaymentOfYear: %w", err)
	}
	return oldValue.ProductPaymentOfYear, nil
}

// AddProductPaymentOfYear adds f to product_payment_of_year.
func (m *ProductMutation) AddProductPaymentOfYear(f float64) {
	if m.addproduct_payment_of_year != nil {
		*m.addproduct_payment_of_year += f
	} else {
		m.addproduct_payment_of_year = &f
	}
}

// AddedProductPaymentOfYear returns the value that was added to the product_payment_of_year field in this mutation.
func (m *ProductMutation) AddedProductPaymentOfYear() (r float64, exists bool) {
	v := m.addproduct_payment_of_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductPaymentOfYear reset all changes of the "product_payment_of_year" field.
func (m *ProductMutation) ResetProductPaymentOfYear() {
	m.product_payment_of_year = nil
	m.addproduct_payment_of_year = nil
}

// SetGenderID sets the Gender edge to Gender by id.
func (m *ProductMutation) SetGenderID(id int) {
	m._Gender = &id
}

// ClearGender clears the Gender edge to Gender.
func (m *ProductMutation) ClearGender() {
	m.cleared_Gender = true
}

// GenderCleared returns if the edge Gender was cleared.
func (m *ProductMutation) GenderCleared() bool {
	return m.cleared_Gender
}

// GenderID returns the Gender id in the mutation.
func (m *ProductMutation) GenderID() (id int, exists bool) {
	if m._Gender != nil {
		return *m._Gender, true
	}
	return
}

// GenderIDs returns the Gender ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GenderID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) GenderIDs() (ids []int) {
	if id := m._Gender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGender reset all changes of the "Gender" edge.
func (m *ProductMutation) ResetGender() {
	m._Gender = nil
	m.cleared_Gender = false
}

// SetGoupOfAgeID sets the Goup_Of_Age edge to GroupOfAge by id.
func (m *ProductMutation) SetGoupOfAgeID(id int) {
	m._Goup_Of_Age = &id
}

// ClearGoupOfAge clears the Goup_Of_Age edge to GroupOfAge.
func (m *ProductMutation) ClearGoupOfAge() {
	m.cleared_Goup_Of_Age = true
}

// GoupOfAgeCleared returns if the edge Goup_Of_Age was cleared.
func (m *ProductMutation) GoupOfAgeCleared() bool {
	return m.cleared_Goup_Of_Age
}

// GoupOfAgeID returns the Goup_Of_Age id in the mutation.
func (m *ProductMutation) GoupOfAgeID() (id int, exists bool) {
	if m._Goup_Of_Age != nil {
		return *m._Goup_Of_Age, true
	}
	return
}

// GoupOfAgeIDs returns the Goup_Of_Age ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GoupOfAgeID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) GoupOfAgeIDs() (ids []int) {
	if id := m._Goup_Of_Age; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoupOfAge reset all changes of the "Goup_Of_Age" edge.
func (m *ProductMutation) ResetGoupOfAge() {
	m._Goup_Of_Age = nil
	m.cleared_Goup_Of_Age = false
}

// SetOfficerID sets the Officer edge to Officer by id.
func (m *ProductMutation) SetOfficerID(id int) {
	m._Officer = &id
}

// ClearOfficer clears the Officer edge to Officer.
func (m *ProductMutation) ClearOfficer() {
	m.cleared_Officer = true
}

// OfficerCleared returns if the edge Officer was cleared.
func (m *ProductMutation) OfficerCleared() bool {
	return m.cleared_Officer
}

// OfficerID returns the Officer id in the mutation.
func (m *ProductMutation) OfficerID() (id int, exists bool) {
	if m._Officer != nil {
		return *m._Officer, true
	}
	return
}

// OfficerIDs returns the Officer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OfficerID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) OfficerIDs() (ids []int) {
	if id := m._Officer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOfficer reset all changes of the "Officer" edge.
func (m *ProductMutation) ResetOfficer() {
	m._Officer = nil
	m.cleared_Officer = false
}

// AddProductInsuranceIDs adds the product_insurance edge to Insurance by ids.
func (m *ProductMutation) AddProductInsuranceIDs(ids ...int) {
	if m.product_insurance == nil {
		m.product_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.product_insurance[ids[i]] = struct{}{}
	}
}

// RemoveProductInsuranceIDs removes the product_insurance edge to Insurance by ids.
func (m *ProductMutation) RemoveProductInsuranceIDs(ids ...int) {
	if m.removedproduct_insurance == nil {
		m.removedproduct_insurance = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_insurance[ids[i]] = struct{}{}
	}
}

// RemovedProductInsurance returns the removed ids of product_insurance.
func (m *ProductMutation) RemovedProductInsuranceIDs() (ids []int) {
	for id := range m.removedproduct_insurance {
		ids = append(ids, id)
	}
	return
}

// ProductInsuranceIDs returns the product_insurance ids in the mutation.
func (m *ProductMutation) ProductInsuranceIDs() (ids []int) {
	for id := range m.product_insurance {
		ids = append(ids, id)
	}
	return
}

// ResetProductInsurance reset all changes of the "product_insurance" edge.
func (m *ProductMutation) ResetProductInsurance() {
	m.product_insurance = nil
	m.removedproduct_insurance = nil
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.product_name != nil {
		fields = append(fields, product.FieldProductName)
	}
	if m.product_price != nil {
		fields = append(fields, product.FieldProductPrice)
	}
	if m.product_time != nil {
		fields = append(fields, product.FieldProductTime)
	}
	if m.product_payment_of_year != nil {
		fields = append(fields, product.FieldProductPaymentOfYear)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldProductName:
		return m.ProductName()
	case product.FieldProductPrice:
		return m.ProductPrice()
	case product.FieldProductTime:
		return m.ProductTime()
	case product.FieldProductPaymentOfYear:
		return m.ProductPaymentOfYear()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldProductName:
		return m.OldProductName(ctx)
	case product.FieldProductPrice:
		return m.OldProductPrice(ctx)
	case product.FieldProductTime:
		return m.OldProductTime(ctx)
	case product.FieldProductPaymentOfYear:
		return m.OldProductPaymentOfYear(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case product.FieldProductPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPrice(v)
		return nil
	case product.FieldProductTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductTime(v)
		return nil
	case product.FieldProductPaymentOfYear:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPaymentOfYear(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_price != nil {
		fields = append(fields, product.FieldProductPrice)
	}
	if m.addproduct_time != nil {
		fields = append(fields, product.FieldProductTime)
	}
	if m.addproduct_payment_of_year != nil {
		fields = append(fields, product.FieldProductPaymentOfYear)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldProductPrice:
		return m.AddedProductPrice()
	case product.FieldProductTime:
		return m.AddedProductTime()
	case product.FieldProductPaymentOfYear:
		return m.AddedProductPaymentOfYear()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldProductPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPrice(v)
		return nil
	case product.FieldProductTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductTime(v)
		return nil
	case product.FieldProductPaymentOfYear:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPaymentOfYear(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldProductName:
		m.ResetProductName()
		return nil
	case product.FieldProductPrice:
		m.ResetProductPrice()
		return nil
	case product.FieldProductTime:
		m.ResetProductTime()
		return nil
	case product.FieldProductPaymentOfYear:
		m.ResetProductPaymentOfYear()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Gender != nil {
		edges = append(edges, product.EdgeGender)
	}
	if m._Goup_Of_Age != nil {
		edges = append(edges, product.EdgeGoupOfAge)
	}
	if m._Officer != nil {
		edges = append(edges, product.EdgeOfficer)
	}
	if m.product_insurance != nil {
		edges = append(edges, product.EdgeProductInsurance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeGender:
		if id := m._Gender; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeGoupOfAge:
		if id := m._Goup_Of_Age; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeOfficer:
		if id := m._Officer; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeProductInsurance:
		ids := make([]ent.Value, 0, len(m.product_insurance))
		for id := range m.product_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproduct_insurance != nil {
		edges = append(edges, product.EdgeProductInsurance)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeProductInsurance:
		ids := make([]ent.Value, 0, len(m.removedproduct_insurance))
		for id := range m.removedproduct_insurance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Gender {
		edges = append(edges, product.EdgeGender)
	}
	if m.cleared_Goup_Of_Age {
		edges = append(edges, product.EdgeGoupOfAge)
	}
	if m.cleared_Officer {
		edges = append(edges, product.EdgeOfficer)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeGender:
		return m.cleared_Gender
	case product.EdgeGoupOfAge:
		return m.cleared_Goup_Of_Age
	case product.EdgeOfficer:
		return m.cleared_Officer
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeGender:
		m.ClearGender()
		return nil
	case product.EdgeGoupOfAge:
		m.ClearGoupOfAge()
		return nil
	case product.EdgeOfficer:
		m.ClearOfficer()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeGender:
		m.ResetGender()
		return nil
	case product.EdgeGoupOfAge:
		m.ResetGoupOfAge()
		return nil
	case product.EdgeOfficer:
		m.ResetOfficer()
		return nil
	case product.EdgeProductInsurance:
		m.ResetProductInsurance()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}
